#include "state.rspl"
#include "math.rspl"

function RDPQ_Send(u16<$s4> dmemStart, u16<$s3> dmaDmemEnd);

// See: https://n64brew.dev/wiki/Reality_Display_Processor/Commands
#define RDP_CMD_PRIM  0x3A00'0000
#define RDP_CMD_DEPTH 0x2E
#define RDP_CMD_RECT  0x36
#define RDP_CMD_TEX_RECT 0x24

// size of the 'T3DParticle' struct, containing 2 interleaved particles each
#define PARTICLE_INPUT_SIZE 16

// max site before flush, this can be the combined size of CLIP_BUFFER_TMP + CLIP_BUFFER_RESULT
// it must be a multiple of 24, and assume one extra 24 bytes over the limit to still fit
#define RDP_FLUSH_SIZE 504
// uvgen params re-purposed for base particle size
#define STATE_PART_SCALE UV_GEN_PARAMS

#define RDP_POS_MASK 0b1111'1111'1111

@Align(8)
function T3DCmd_DrawParticles(s16 dataSize, s32 rdramAddr, u32 textureConf)
{
  u16<$s4> dmaDmem = TRI_BUFFER;
  dmaDmem += 8; // needs 16-byte alignment for packed loads
  u32<$t0> dmaSize = dataSize & 0xFFFF;

  // Reserve regs used by RDPQ_Send, DMA and indirect functions.
  // since we call it in our loop, we must reserve them here, and they can only use it for temporaries.
  // Those function are part of libdragon and in ASM, so we have no control over them.
  u8<$t3> syncOngoing;
  s32<$s0> rdram_cur;
  undef dataSize;
  u32<$t4> temp1;
  u32<$t1> clipA; u8<$t2> cmdRdpRect;
  u32<$t5> clipB; u8<$a0> cmdRdpDepth;
  u32<$t7> cmdRdpColor;
  // end of reserved regs

  // Load in all particles at once, re-use vertex buffer here
  u32 ptrInEnd = dmaDmem + dmaSize;
  rdramAddr = resolveSegmentAddr(rdramAddr);
  dma_in_async(dmaDmem, rdramAddr, dmaSize);

  u32 ptrIn = dmaDmem;

  dmaDmem = CLIP_BUFFER_TMP; // make 'dmaDmem' point to the output buffer now
  u16<$s3> dmaDmemEnd = CLIP_BUFFER_TMP;
  u16 dmaDmemFlush = dmaDmemEnd + RDP_FLUSH_SIZE;

  vec32 mat0, mat1, mat2, mat3;
  loadCurrentModelProjMat(mat0, mat1, mat2, mat3);

  vec32 screenSize:sint = load(SCREEN_SCALE_OFFSET).xyzwxyzw;
  screenSize:sfract = 0;
  screenSize >>= 4;

  vec16 screenOffset = load(SCREEN_SCALE_OFFSET, 0x08).xyzwxyzw;
  vec16 normScaleW = load(NORM_SCALE_W).xyzwxyzw;

  vec16 screenMin, screenMax;
  loadScissorMinMax(screenMin, screenMax);

  vec16 localPartSize;
  vec16 particleParams = 0;

  #define VEC_CONF_SCALE particleParams.z
  #define VEC_CONF_SUB   particleParams.w
  #define VEC_CONF_MASK  particleParams.Z

  {
    s8 partScale = load(STATE_PART_SCALE, 1);
    VEC_CONF_SCALE = partScale;
    s8 sizeSub = load(STATE_PART_SCALE, 3);
    VEC_CONF_SUB = sizeSub;
    s8 sizeMask = load(STATE_PART_SCALE, 2);
    VEC_CONF_MASK = sizeMask;

    // xy/XY is used as a UV offset, this must be in that lane to allow for a direct addition
    s8 texOffset = load(STATE_PART_SCALE, 0);
    texOffset <<= 5;
    particleParams.x = texOffset;
    particleParams.X = particleParams.x;
  }

  dma_await();

  //asm("emux_dump_vpr %0", screenMax);

  u32 posA, posB, posEndA, posEndB;
  vec32 posClip;

  // de-phase parts of the loop, this part is also at the end of the loop
  vec16 posStart = load_vec_s8(ptrIn, 0x00);
  posStart >>= 8;
  localPartSize = posStart + VEC_CONF_SCALE;
  posStart.w = 1;
  posStart.W = 1;

  if(textureConf) {
    drawTexturedParticles();
    RA = RSPQ_Loop; // @TODO: add RSPL auto-opt. for this (needs RA assign)
    goto RDPQ_Send;
  }

  undef textureConf; u32<$a2> temp0;

  // Iterate over all points, transform + clip, save back those that need to be drawn
  // the transformed amount might be smaller and shifted due to that
  loop {
    localPartSize &= VEC_CONF_MASK;
    localPartSize -= VEC_CONF_SUB;
    localPartSize = abs(localPartSize);

    // point to clip space
    mulMat4Vec8(mat0, mat1, mat2, mat3, posStart, posClip);

    // only clip-check against Z to prevent overflow, X/Y is clamped in screen-space later
    temp1 = clip(posClip, posClip.wwwwWWWW);
    clipA = temp1 & 0b0000'0100'0000'0100;
    clipB = temp1 & 0b0100'0000'0100'0000;

    vec32 invW;
    posClip *= normScaleW:ufract;

    invW.w = invert_half(posClip).w;
    invW.W = invert_half(posClip).W;

    // store particle size in W to only do one perspective division
    posClip.w = localPartSize.w;
    posClip.W = localPartSize.W;

    // perspective division
    posClip *= invW.wwwwWWWW;
    undef invW;

    // transform to screen-space, this is the center of the particles and its depth-value
    vec32 posScreen = posClip * screenSize;
    vec16 posCenter = posScreen:sint + screenOffset;

    // extend to both sides for start/end point...
    vec16 posEnd = posCenter + posClip:sint.wwwwWWWW;
    posStart = posCenter - posClip:sint.wwwwWWWW;

    // ... and clamp to the edges of the screen
    posEnd = min(posEnd, screenMax);
    posStart = max(posStart, screenMin);

    encodeRectPos(posA, posB, posStart);
    encodeRectPos(posEndA, posEndB, posEnd);

    // now check if it's completely outside the screen or has a zero-size
    vec16 extend = posStart < posEnd;
    temp1 = get_vcc();

    temp0 = temp1 & 0b0000'0011; // only check X/Y
    clipA |= temp0;

    temp0 = temp1 & 0b0011'0000;
    clipB |= temp0;

    // load color and prepare RPD command IDs
    vec16 color = load(ptrIn, 0x08).xyzw;
    cmdRdpColor = RDP_CMD_PRIM;
    cmdRdpDepth = RDP_CMD_DEPTH;
    cmdRdpRect = RDP_CMD_RECT;

    // Save the rectangles now. Each one consists of 3 commands: color, depth, rect
    // The first one is always saved here to allow better reordering,
    // however both will only submit it by advancing 'dmaDmemEnd'

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    // "Prim Color": |0x3A |  -  |    LOD    ||      color (RGBA)     |
    store(cmdRdpColor, dmaDmemEnd);
    store(color.xy, dmaDmemEnd, 4);

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    // "Prim Depth": |0x2E |  -  |  -  |  -  ||   depth   |  delta-Z  |
    posCenter.w = 0; // will be the z-delta, always 0
    store(cmdRdpDepth,  dmaDmemEnd, 0x00, 8);
    store(posCenter.zw, dmaDmemEnd, 0x04, 8);

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    //  "Fill Rect": |0x36 |   X0/Y0 (10.2)  ||  -  |  X1/Y1 (10.2)   |
    store(posA, dmaDmemEnd, 0x04, 16);
    @Barrier("pos-cmd") store(posEndA, dmaDmemEnd, 0x00, 16);
    @Barrier("pos-cmd") store(cmdRdpRect, dmaDmemEnd, 0x00, 16);

    // load particle for next iteration
    ptrIn += PARTICLE_INPUT_SIZE;
    posStart = load_vec_s8(ptrIn, 0x00, PARTICLE_INPUT_SIZE);
    posStart >>= 8;

    localPartSize = posStart + VEC_CONF_SCALE;
    posStart.w = 1;
    posStart.W = 1;

    if(clipA == 0b0000'0011) {
      dmaDmemEnd += 24;
    }

    // Second rectangle:
    posCenter.W = 0;
    if(clipB == 0b0011'0000) {
      store(cmdRdpColor, dmaDmemEnd);
      store(color.zw, dmaDmemEnd, 4);

      store(cmdRdpDepth,  dmaDmemEnd, 0x00, 8);
      store(posCenter.ZW, dmaDmemEnd, 0x04, 8);

      store(posB, dmaDmemEnd, 0x04, 16);
      @Barrier("pos-cmd") store(posEndB, dmaDmemEnd, 0x00, 16);
      @Barrier("pos-cmd") store(cmdRdpRect, dmaDmemEnd, 0x00, 16);

      dmaDmemEnd += 24;
    }

    // When the RDP buffer in DMEM is full, submit and DMA them out.
    // If anything is left, a last call after the loop will submit the rest.
    if(dmaDmemEnd >= dmaDmemFlush) {
      RDPQ_Send(dmaDmem, dmaDmemEnd);
      dmaDmemEnd = dmaDmem;
    }
  } while (ptrIn != ptrInEnd)

  // submit the rest of the buffer (if any)
  RA = RSPQ_Loop; // @TODO: add RSPL auto-opt. for this (needs RA assign)
  goto RDPQ_Send;
}

function T3DCmd_DrawParticles_End() {}

macro drawTexturedParticles()
{
  vec16 textureScale;

  textureScale.x = textureConf;
  textureScale = textureScale.x;
  textureConf >>= 16;
  textureScale.z = textureConf;

  vec16 uvStart, uvDelta;
  dmaDmemFlush -= 64;

  undef textureConf; u32<$a2> temp0;

  // Iterate over all points, transform + clip, save back those that need to be drawn
  // the transformed amount might be smaller and shifted due to that
  loop {
    localPartSize &= VEC_CONF_MASK;
    localPartSize -= VEC_CONF_SUB;
    localPartSize = abs(localPartSize);

    // point to clip space
    mulMat4Vec8(mat0, mat1, mat2, mat3, posStart, posClip);

    // only clip-check against Z to prevent overflow, X/Y is clamped in screen-space later
    temp1 = clip(posClip, posClip.wwwwWWWW);
    clipA = temp1 & 0b0000'0100'0000'0100;
    clipB = temp1 & 0b0100'0000'0100'0000;

    vec32 invW;
    posClip *= normScaleW:ufract;

    invW.w = invert_half(posClip).w;
    invW.W = invert_half(posClip).W;

    // store particle size in W to only do one perspective division
    posClip.w = localPartSize.w;
    posClip.W = localPartSize.W;

    // perspective division
    posClip *= invW.wwwwWWWW;
    undef invW;

    // transform to screen-space, this is the center of the particles and its depth-value
    vec32 posScreen = posClip * screenSize;
    vec16 posCenter = posScreen:sint + screenOffset;

    // extend to both sides for start/end point...
    vec16 posEnd = posCenter + posClip:sint.wwwwWWWW;
    posStart = posCenter - posClip:sint.wwwwWWWW;

    uvStart = posStart < screenMin ? posStart : VZERO;
    uvStart = VZERO - uvStart; // @TODO opt?

    // ... and clamp to the edges of the screen
    posEnd = min(posEnd, screenMax);
    posStart = max(posStart, screenMin);

    encodeRectPos(posA, posB, posStart);
    encodeRectPos(posEndA, posEndB, posEnd);

    // now check if it's completely outside the screen or has a zero-size
    VTEMP = posStart < posEnd;
    temp1 = get_vcc();

    temp0 = temp1 & 0b0000'0011; // only check X/Y
    clipA |= temp0;

    temp0 = temp1 & 0b0011'0000;
    clipB |= temp0;

    // calculate UVs / deltas
    uvDelta:sfract.w = invert_half(posClip).w; // the larger the particle, the smaller the UV delta
    uvDelta:sfract.W = invert_half(posClip).W;
    uvDelta = textureScale * uvDelta.wwwwWWWW;

    vec16 uvOff = 0;
    s8 localOffset = load(ptrIn, 11);
    uvOff.x = localOffset;
    uvOff <<= 5;
    uvOff += particleParams;
    uvOff &= textureScale.z;

    uvStart <<= 4; // @TODO opt?
    uvStart = uvStart:sfract * uvDelta.xxxxXXXX;
    uvStart += uvOff;
    uvStart <<= 4;

    // load color and prepare RPD command IDs
    vec16 color = load(ptrIn, 0x08).xyzw;
    cmdRdpColor = RDP_CMD_PRIM;
    cmdRdpDepth = RDP_CMD_DEPTH;
    cmdRdpRect = RDP_CMD_TEX_RECT;

    // Save the rectangles now. Each one consists of 3 commands: color, depth, rect
    // The first one is always saved here to allow better reordering,
    // however both will only submit it by advancing 'dmaDmemEnd'

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    // "Prim Color": |0x3A |  -  |    LOD    ||      color (RGBA)     |
    store(cmdRdpColor, dmaDmemEnd);
    store(color.xy, dmaDmemEnd, 4);

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    // "Prim Depth": |0x2E |  -  |  -  |  -  ||   depth   |  delta-Z  |
    posCenter.w = 0; // will be the z-delta, always 0
    store(cmdRdpDepth,  dmaDmemEnd, 0x00, 8);
    store(posCenter.zw, dmaDmemEnd, 0x04, 8);

    //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
    //   "Tex Rect": |0x36 |   X0/Y0 (10.2)  ||  -  |  X1/Y1 (10.2)   |
    //               |  S (10.5) | T (10.5)  || Ds (10.5) | Dt (10.5) |
    store(posA, dmaDmemEnd, 0x04, 16);
    @Barrier("pos-cmd") store(posEndA, dmaDmemEnd, 0x00, 16);
    @Barrier("pos-cmd") store(cmdRdpRect, dmaDmemEnd, 0x00, 16);
    store(uvStart.xy, dmaDmemEnd, 0, 24);
    store(uvDelta.xy, dmaDmemEnd, 4, 24);

    // load particle for next iteration
    ptrIn += PARTICLE_INPUT_SIZE;
    posStart = load_vec_s8(ptrIn, 0x00, PARTICLE_INPUT_SIZE);
    posStart >>= 8;

    localPartSize = posStart + VEC_CONF_SCALE;
    posStart.w = 1;
    posStart.W = 1;

    if(clipA == 0b0000'0011) {
      dmaDmemEnd += 32;
    }

    // Second rectangle:
    posCenter.W = 0;

    if(clipB == 0b0011'0000) {
      store(cmdRdpColor, dmaDmemEnd);
      store(color.zw, dmaDmemEnd, 4);

      store(cmdRdpDepth,  dmaDmemEnd, 0x00, 8);
      store(posCenter.ZW, dmaDmemEnd, 0x04, 8);

      store(posB, dmaDmemEnd, 0x04, 16);
      @Barrier("pos-cmd") store(posEndB, dmaDmemEnd, 0x00, 16);
      @Barrier("pos-cmd") store(cmdRdpRect, dmaDmemEnd, 0x00, 16);
      store(uvStart.XY, dmaDmemEnd, 0, 24);
      store(uvDelta.XY, dmaDmemEnd, 4, 24);

      dmaDmemEnd += 32;
    }

    // When the RDP buffer in DMEM is full, submit and DMA them out.
    // If anything is left, a last call after the loop will submit the rest.
    if(dmaDmemEnd >= dmaDmemFlush) {
      RDPQ_Send(dmaDmem, dmaDmemEnd);
      dmaDmemEnd = dmaDmem;
    }
  } while (ptrIn != ptrInEnd)
}

/**
 * Converts a screen-space position to a 10.2 rect. command position
 * @param outA XY pos for .xy component of pos
 * @param outB XY pos for .XY component of pos
 * @param pos input position
 */
macro encodeRectPos(u32 outA, u32 outB, vec16 pos)
{
  outA = pos.y;
  outA &= RDP_POS_MASK;
  u32 tmp = pos.x;
  tmp <<= 12;
  outA |= tmp;

  outB = pos.Y;
  outB &= RDP_POS_MASK;
  tmp = pos.X;
  tmp <<= 12;
  outB |= tmp;
}

/**
 * Loads the current scissor area from the shared 'RDPQ_SCISSOR_RECT' setting
 * @param screenMin minimum (sets .xy & .XY)
 * @param screenMax maximum (sets .xy & .XY)
 */
macro loadScissorMinMax(vec16 screenMin, vec16 screenMax)
{
  screenMax.w = RDP_POS_MASK; // mask to extract 10.2 values
  u32 extMax = load(RDPQ_SCISSOR_RECT, 4);
  u32 extMin = load(RDPQ_SCISSOR_RECT, 0);

  temp1 = extMax >> 12;
  screenMax.x = temp1;  screenMax.X = temp1;
  screenMax.y = extMax; screenMax.Y = extMax;

  temp1 = extMin >> 12;
  screenMin.x = temp1;  screenMin.X = temp1;
  screenMin.y = extMin; screenMin.Y = extMin;

  screenMax &= screenMax.w;
  screenMin &= screenMax.w;
}

// insert dummy commands to make the data section match
command<0> Cmd_DummyStart(u32 vert0, u32 ptrVertB) {}
command<13> Cmd_DummyEnd() {}