#define TRI_BUFFER_COUNT 70
#define LIGHT_COUNT 4

// settings for RDPQ_Triangle
#define RDPQ_TRIANGLE_CUSTOM_VTX 1
#define VTX_ATTR_XY          0x00
#define VTX_ATTR_Z           0x04
#define VTX_ATTR_CLIPFLAGS   0x06
#define VTX_ATTR_REJFLAGS    0x07
#define VTX_ATTR_RGBA        0x08
#define VTX_ATTR_ST          0x0C
#define VTX_ATTR_CLIPPOSi    0x10
#define VTX_ATTR_Wi          0x16
#define VTX_ATTR_CLIPPOSf    0x18
#define VTX_ATTR_Wf          0x1E
#define VTX_ATTR_INVWi       0x20
#define VTX_ATTR_INVWf       0x22

#define RDPQ_TRIANGLE_VTX1 a0
#define RDPQ_TRIANGLE_VTX2 a1
#define RDPQ_TRIANGLE_VTX3 a2

#define RDPQ_TRIANGLE_VTX1_DMEM 0,v1
#define RDPQ_TRIANGLE_VTX2_DMEM 4,v1
#define RDPQ_TRIANGLE_VTX3_DMEM 2,v1

// Size of the internal triangle format
// @TODO: add const expr. eval to RSPL
#define TRI_SIZE   36
#define TRI_SIZE_2 72
#define TRI_SIZE_3 108

#define RDP_CMD_MAX_SIZE 176

// Single light (RGBA duplicated, duplicated direction packed as s8)
#define LIGHT_SIZE 16
#define MATRIX_SIZE 0x40

// Debug-Flag, used to measure performance excl. triangle draws
#define DRAW_TRIS 1
// Debug-Flag, enables metrics on how many tris are drawn & clipped
//#define DEBUG_LOG_TRIS 1

// RDPQ Stuff (@TODO: move RDPQ_Send back into libdragon)
#define DP_STATUS_END_VALID 512
#define RDPQ_DYNAMIC_BUFFER_SIZE 65536

include "rsp_queue.inc"
include "rdpq_macros.h"
include "./asm/rspq_triangle.inc"

state
{
  // external libdragon labels
  extern u32 RDPQ_OTHER_MODES;
  extern u16 RSPQ_Loop;
  extern u16 RSPQ_SCRATCH_MEM;
  extern u16 CLIPPING_CODE_TARGET;
  extern u32 RDPQ_SCISSOR_RECT;

  alignas(8) vec16 MATRIX_PROJ[4];   // projection matrix
  alignas(8) vec16 MATRIX_MVP[4];    // view * model * projection
  alignas(8) u8 MATRIX_NORMAL[24]; // fractional normal matrix (@TODO: only needs 1.5 vec16's)

  /**
   * Buffer format (RDPQ_Triangle compatible):
   *
   *   Type |     Name  | Offset
   * -------+-----------+--------
   * s16[2] | Pos-XY    | 0x00
   * s16    | Depth     | 0x04
   * u8     | Clip-Code | 0x06
   * u8     | Rej. Code | 0x07
   * u8[4]  | Color     | 0x08
   * s16[2] | UV        | 0x0C
   * s16[3] | Clip-Pos  | 0x10  (t3d specific)
   * s16    | W         | 0x16
   * f16[3] | Clip-Pos  | 0x18  (t3d specific)
   * f16    | W         | 0x1E
   * s16.16 | InvW      | 0x20
   * -------+-----------+-0x24---
   */
  u8 TRI_BUFFER[TRI_BUFFER_COUNT][TRI_SIZE];

  // Temp. buffer for clipped extra vertices.
  // This is also used as a temp. buffer for DMA'ing in new vertices.
  // For clipping data, the format is the same as TRI_BUFFER.
  alignas(16)
  u8 CLIP_BUFFER_TMP[7][TRI_SIZE];

  // NOTE: this space inbetween buffers is overflowing in the vertex load DMA
  // only put stuff here to fill the alignment gap that is used outside of this
  u16 CLIP_RA;

  // Last buffer where final clipping triangles are stored.
  // During clipping, vertices alternate between CLIP_BUFFER_TMP & B.
  alignas(16)
  u8 CLIP_BUFFER_RESULT[8][TRI_SIZE];

  vec16 SCREEN_SCALE_OFFSET = {
    0, 0, 0,           0, // screen size scale (.xyzw)
    0, 0, 0x3FFF, 0x00FF  // screen size offset (.XYZW), W is used for a fake clipping-code in 'triToScreenSpace'
  };

  vec16 NORMAL_MASK_SHIFT = {
    // Mask to extract 5.6.5-bit values for normal vectors (.xyzw)
    0b11111'000000'00000,
    0b00000'111111'00000,
    0b00000'000000'11111,
    0,
    // And the mul. factor to shift them into a fraction (.XYZW)
    1, 32, 2048, 0
  };

  // Plane-normals for clipping, the guard value can be overwritten with a command.
  alignas(8) s8 CLIPPING_PLANES[5][4] = {
  // X  Y  Z | guard
     1, 0, 0,   1,
     0, 1, 0,   1,
     0, 0, 1,   1,
     1, 0, 0,  -1,
     0, 1, 0,  -1
  };

  u16 UV_GEN_PARAMS[2] = {0, 0}; // user defined args. for the UV function

  // scales clip-space W to be 1 in the middle of near to far
  // the `0` are set at runtime to a fractional value
  alignas(8) vec16 NORM_SCALE_W = {
    0xFFFF, 0xFFFF, 0xFFFF, 0x0000,
    0x0000, 0x0000, 0x0000, 0xFFFF
  };

  u32 SEGMENT_TABLE[8] = {0};

  // Lighting
  u32 COLOR_AMBIENT[2];   // RGBA8 (duplicated) | <unused> (saved IMEM)
  alignas(4) u8 LIGHT_DIR_COLOR[LIGHT_SIZE][LIGHT_COUNT]; // RGBA8 (duplicated) | Direction packed as s8 (duplicated)

  u32 TRI_COMMAND = {0}; // for RDPQ_Triangle
  s32 MATRIX_STACK_PTR = {0}; // current matrix stack pointer in RDRAM, set once during init

  // Fog settings: index 0/1 is the scale as a s16.16, index 2 the scale as a s16 int.
  // The last value is used as a limiter to prevent overflows.
  s16 FOG_SCALE_OFFSET[4] = {0, 0, 0, 32767};
  u16 RDPQ_TRI_BUFF_OFFSET = {0};
  u16 SCREEN_UVGEN_SCALE = {0};
  u16 VERTEX_FX_FUNC = {0}; // points top the current 'VertexFX_' function in IMEM

  u8 FACE_CULLING = {0}; // 0=cull front, 1=cull back, 2=no-culling
  u8 FOG_STORE_OFFSET  = {VTX_ATTR_ST}; // offset (relative to current vertex) where to store fog, set to UV for no fog
  u8 ACTIVE_LIGHT_SIZE = {0}; // light count * light size
}

temp_state {

  // address of the clipping code to load in RDRAM
  // first byte (MSB) stores if th code is already loaded or not
  u32 CLIP_CODE_ADDR = {0};
  u32 CLIP_CODE_ORG_ADDR = {0}; // address of the original code (this overlay here)
  u16 CLIP_CODE_SIZE = {0}; // size to copy
}

// Libdragon functions
function RDPQ_Triangle_Send_Async(u32<$a0> ptrVert0, u32<$a1> ptrVert1, u32<$a2> ptrVert2, u32<$sp> cullDest);
function RDPQ_Triangle_Send_End();

// Packs +xyz & -xyz into a single byte
macro packClipCode(u32 res, u32 clipCode)
{
  res = clipCode & 0b0000'0111'0000'0111;
  u32 tmp = res >> 5; //  -zyx      +xyx
  res |= tmp;
}

// Same as packClipCode, inverts the clipcode to only use one operation later on
macro packClipCodeInverted(u32 res, u32 clipCode)
{
  res = clipCode & 0b0000'0111'0000'0111;
  u32 tmp = res >> 5; //  -zyx      +xyx
  res = res ~| tmp;
}

// Loads currently active model matrix (premultiplied with proj. matrix) into registers
// This already duplicates it for 2-vector operations.
macro loadCurrentModelProjMat(vec32 mat0, vec32 mat1, vec32 mat2, vec32 mat3)
{
  u16 address = MATRIX_MVP;
  mat0 = load(address, 0x00).xyzwxyzw;
  mat1 = load(address, 0x10).xyzwxyzw;
  mat2 = load(address, 0x20).xyzwxyzw;
  mat3 = load(address, 0x30).xyzwxyzw;
}

// Loads currently active model matrix into registers
// This already duplicates it for 2-vector operations.
macro loadCurrentNormalMat(vec16 mat0, vec16 mat1, vec16 mat2)
{
  u16 address = MATRIX_NORMAL;
  mat0 = load(address, 0x00).xyzwxyzw;
  mat1 = load(address, 0x08).xyzwxyzw;
  mat2 = load(address, 0x10).xyzwxyzw;
}

// resolves a (potentially) segmented RDRAM address into a physical one
macro resolveSegmentAddr(u32 addrOut, u32 addrIn) {
  u32 segment = addrIn >> 24;
  segment = load(segment, SEGMENT_TABLE);
  addrOut = addrIn + segment;
}
