/***************************************
 *  _____ _             _____ ____     *
 * |_   _(_)_ __  _   _|___ /|  _ \    *
 *   | | | | '_ \| | | | |_ \| | | |   *
 *   | | | | | | | |_| |___) | |_| |   *
 *   |_| |_|_| |_|\__, |____/|____/    *
 *                |___/                *
 *      3D-microcode for libdragon     *
 *                                     *
 * @copyright Max Beb√∂k 2023-2024      *
 * @license MIT                        *
 ***************************************/

#include "state.rspl"
#include "math.rspl"

#ifdef OVERLAY_CLIPPING
  #include "clipping.rspl"
#else

/**
 * Loads & transforms 3D vertices into the internal buffer, later to be used by triangles.
 * This fully prepares them to be used by RDPQ_Triangle, while still being able to
 * be clipped and transformed into screen-space again if needed.
 *
 * @param bufferSize size in bytes to load (@TODO: add offset too)
 * @param rdramVerts RDRAM address to load vertices from
 * @param bufferSize 2 u16 DMEM addresses, MSBs set where to DMA the input to, LSBs set where to store the result
 */
@Align(8)
command<4> T3DCmd_VertLoad(u32 bufferSize, u32 rdramVerts, u32 addressInOut)
{
  CLIPPING_CODE_TARGET: // marks the place where the clipping code can be loaded in to

  // load all vertices in a single DMA, processing them as the loop goes.
  // NOTE: the input vertex-size is smaller than the internal one, so we can't do it in place.
  // Instead, offset the buffer enough to not cause an overlap with read/writes on the same vertex.
  u32<$s4> prt3d = addressInOut >> 16;

  u32<$t0> copySize = bufferSize & 0xFFFF;
  u32 ptr3dEnd = prt3d + copySize;

  u32<$s0> dmaAddrRDRAM;
  resolveSegmentAddr(dmaAddrRDRAM, rdramVerts);
  dma_in_async(prt3d, dmaAddrRDRAM, copySize);

  vec32 mat0, mat1, mat2, mat3;
  loadCurrentModelProjMat(mat0, mat1, mat2, mat3);

  vec16 matN0, matN1, matN2;
  loadCurrentNormalMat(matN0, matN1, matN2);

  vec16 normMask = load(NORMAL_MASK_SHIFT, 0x00).xyzwxyzw;
  vec16 normShift = load(NORMAL_MASK_SHIFT, 0x08).xyzwxyzw;

  vec16 guardBandScale = load(CLIPPING_PLANES).xy;
  guardBandScale = guardBandScale.y;

  vec32 screenSize:sint = load(SCREEN_SCALE_OFFSET).xyzwxyzw;
  screenSize:sfract = 0;
  screenSize >>= 4;

  vec16 screenOffset = load(SCREEN_SCALE_OFFSET, 0x08).xyzwxyzw;
  vec16 fogScaleOffset = load(FOG_SCALE_OFFSET).xyzw;

  vec16 normScaleW = load(NORM_SCALE_W).xyzwxyzw;

  u32 ptrBuffA = addressInOut & 0xFFFF; // ptr to first output vertex
  u32 ptrBuffB = ptrBuffA + TRI_SIZE; // ptr to second output vertex

  u16 ptrLight = LIGHT_DIR_COLOR;

  u8 ptrLightEnd = load(ACTIVE_LIGHT_SIZE);
  ptrLightEnd += ptrLight;

  vec16 uvGenArgs;
  uvGenArgs.xy = load(UV_GEN_PARAMS).xy;
  uvGenArgs.XY = load(UV_GEN_PARAMS).xy;
  uvGenArgs.w = load(SCREEN_UVGEN_SCALE).x;

  u8 fogStoreOffset = load(FOG_STORE_OFFSET);
  s16 fogA, fogB;

  // @TODO: racing the DMA is ~40us faster, doesn't work in ares, retest later again
  dma_await();

  // de-phased part of the loop to avoid stalls, this is also done at the end
  vec16 pos = load(prt3d, 0x00);
  vec16 norm = normMask & pos.wwwwWWWW;
  norm *= normShift;

  // Process all vertices and apply transformation & lighting.
  // This always handles 2 vertices at once, most sitting in one register.
  loop
  {
    LOOP_START:
    // Position & Normals
    vec32 posClip;
    vec16 color;

    u16 vertexFxFunc = load(VERTEX_FX_FUNC);

    {
      // load & transform normals, this in not needed when no directional light is present
      // however, an if-statement + the lost ability for reordering is not worth it. (@TODO: do more tests)
      posClip:sfract = matN0:sfract  * norm.xxxxXXXX; // (assign to dummy value)
      posClip:sfract = matN1:sfract +* norm.yyyyYYYY;
      norm           = matN2:sfract +* norm.zzzzZZZZ;

      pos.w = load(CLIPPING_PLANES, 4).x; // loads "1"
      pos.W = load(CLIPPING_PLANES, 4).x;

      // object-space to clip-space
      mulMat4Vec8(mat0, mat1, mat2, mat3, pos, posClip);
      undef pos;

      // input vertex color
      color = load_vec_u8(prt3d, 0x10);
      vec16 lightColor = load_vec_u8(COLOR_AMBIENT); // light color, accumulates directional lights

      // directional
      vec16 lightDirVec  = load_vec_s8(ptrLight, 8);
      while(ptrLight != ptrLightEnd)
      {
        vec16 lightDirScale;
        dotXYZ(lightDirScale, norm, lightDirVec);

        vec16 lightDirColor = load_vec_u8(ptrLight);
        lightDirScale = lightDirColor:ufract * lightDirScale:ufract.xxxxXXXX;

        lightColor:sfract += lightDirScale;
        ptrLight += LIGHT_SIZE;
        lightDirVec = load_vec_s8(ptrLight, 8);
      }

      ptrLight = LIGHT_DIR_COLOR;
      color:sfract *= lightColor:ufract;
    }

    // calc. clipping codes (rejection & clip-prevention)
    u32 clipCodeA, clipCodeB, rejCodesA, rejCodesB;
    {
      vec32<$v02> clipPlaneW = guardBandScale * posClip.wwwwWWWW;

      // Clip code for clipping (incl. band-guard)
      u32 clipCodes = clip(posClip, clipPlaneW);
      clipCodeB = clipCodes >> 4;
      packClipCode(clipCodeA, clipCodes);
      packClipCode(clipCodeB, clipCodeB);

      // Clip-Code for rejection (no band-guard)
      u32 rejCodes = clip(posClip, posClip.wwwwWWWW);
      rejCodesB = rejCodes >> 4;
      packClipCodeInverted(rejCodesA, rejCodes);
      packClipCodeInverted(rejCodesB, rejCodesB);
    }

    posClip *= normScaleW:ufract;

    store(posClip.xyzw, ptrBuffA, VTX_ATTR_CLIPPOSi);
    store(posClip.XYZW, ptrBuffB, VTX_ATTR_CLIPPOSi);

    // now optimistically assume it's on-screen and conv. to screen-space
    posClip.w = invert_half(posClip).w;
    posClip.W = invert_half(posClip).W;

    // Fog
    {
      vec32 fog;

      // add offset, to avoid loads, int/fract are stored in the same vector
      fog:ufract = posClip + fogScaleOffset.z;
      fog:sint   = posClip + fogScaleOffset.y;
      fog *= fogScaleOffset:sint.x;

      vec16 fogMax = fogScaleOffset.w; // invert fog -> 0=no-fog, max=fog
      fog:sint = fogMax - fog:sint;

      fogA = fog:sint.z;
      fogB = fog:sint.Z;
      fogA >>= 7;
      fogB >>= 7;
    }

    // backup clip-pos in case that clipping is required
    // also store inv-W here (in place of W)
    store(posClip.w, ptrBuffA, VTX_ATTR_INVWi);
    store(posClip.W, ptrBuffB, VTX_ATTR_INVWi);

    posClip *= posClip.wwwwWWWW;
    posClip *= screenSize;
    posClip:sint += screenOffset;

    vec16 uv = load(prt3d, 0x18).xyzw;

    @Barrier("pos-cc") store(posClip:sint.xyzw, ptrBuffA, VTX_ATTR_XY);
    @Barrier("pos-cc") store(posClip:sint.XYZW, ptrBuffB, VTX_ATTR_XY);

    @Barrier("color-fog") store_vec_u8(color.x, ptrBuffA, VTX_ATTR_RGBA);
    @Barrier("color-fog") store_vec_u8(color.X, ptrBuffB, VTX_ATTR_RGBA);

    // save fog here, to make this branch-less, fogStoreOffset contains the offset to save it to.
    // if enabled this points to VTX_ATTR_RGBA, otherwise to UV which are then overwritten in vertexFxFunc()
    u32 fogStoreAddr = ptrBuffA + fogStoreOffset;
    @Barrier("color-fog") store(fogA:u8, fogStoreAddr, 3); // store fog in alpha
    fogStoreAddr = ptrBuffB + fogStoreOffset;
    @Barrier("color-fog") store(fogB:u8, fogStoreAddr, 3);

    @Barrier("pos-cc") store(clipCodeA:u8, ptrBuffA, VTX_ATTR_CLIPFLAGS);
    @Barrier("pos-cc") store(clipCodeB:u8, ptrBuffB, VTX_ATTR_CLIPFLAGS);

    @Barrier("pos-cc") store(rejCodesA:u8, ptrBuffA, VTX_ATTR_REJFLAGS);
    @Barrier("pos-cc") store(rejCodesB:u8, ptrBuffB, VTX_ATTR_REJFLAGS);

    pos = load(prt3d, 0x20); // load next pos
    vec16 oldNorm = norm;
    norm = normMask & pos.wwwwWWWW;
    norm *= normShift;

    prt3d += 0x20;

    vec16 temp; // can be used by 'uvGenFunc'
    vertexFxFunc(); // handles the loop condition internally
  }
}

#include "vertexFX.rspl"

/**
 * Sets current screen-size in pixel.
 * @param guardBandFactor s16 with the guard multiplier (should be 1-4)
 * @param screenScale screen-size * 2
 * @param depthAndWScale fractional 16bit scales to normalize W and depth
 */
command<1> T3DCmd_SetScreenSize(s8 guardBandFactor, u32 screenOffsetXY, u32 screenScaleXY, u32 depthAndWScale)
{
  store(depthAndWScale:u32, SCREEN_SCALE_OFFSET, 0x04); // (writes garbage into W, saves a shift)
  store(screenScaleXY, SCREEN_SCALE_OFFSET, 0x00);
  store(screenOffsetXY, SCREEN_SCALE_OFFSET, 0x08);

  store(depthAndWScale:s16, NORM_SCALE_W, 6);
  store(depthAndWScale:s16, NORM_SCALE_W, 8);
  store(depthAndWScale:s16, NORM_SCALE_W, 10);
  store(depthAndWScale:s16, NORM_SCALE_W, 12);

  // guard-band multiplier (W value of the clipping plane, integer)
  guardBandFactor &= 0xF;
  s8 guardBandFactorNeg = ZERO - guardBandFactor;

  store(guardBandFactor,    CLIPPING_PLANES, 3); // +X Plane
  store(guardBandFactor,    CLIPPING_PLANES, 7); // +Y Plane
  //store(guardBandFactor,    CLIPPING_PLANES, 11); // +Z Plane
  store(guardBandFactorNeg, CLIPPING_PLANES, 15); // -X Plane
  store(guardBandFactorNeg, CLIPPING_PLANES, 19); // -Y Plane

  // prepare additional inverse screen-scale, this is used for generated UVs
  {
    vec32 screenSize:sfract = 0;
    s16 screenScaleX = screenScaleXY >> 16;
    screenSize:sint.x = screenScaleX;
    screenSize.x = invert_half(screenSize).x;

    vec16 scaleFactor = screenSize:sfract >> 2;
    scaleFactor += 1;
    store(scaleFactor.x, SCREEN_UVGEN_SCALE);
  }
   //printf("\033[2J"); // clear console
}

/**
 * Sets the range of fog.
 *
 * @param fogScale 16.16 scale factor
 * @param fogOffset 16.16 offset
 */
command<10> T3DCmd_SetFogRange(s16 fogScale, s32 fogOffset)
{
  store(fogScale,  FOG_SCALE_OFFSET, 0x00);
  store(fogOffset, FOG_SCALE_OFFSET, 0x02);
}

/**
 * Enables or disables fog.
 * @param enabled 1=enabled, 0=disabled
 */
command<11> T3DCmd_SetFogState(u8 enabled)
{
  store(enabled, FOG_STORE_OFFSET);
}

/**
 * Sets a light (ambient or directional)
 *
 * @param address ambient or dir. light address (DMEM)
 * @param rgba8 color RGBA8
 * @param dirXYZ normalized packed direction, ignored if zero
 */
command<5> T3DCmd_LightSet(u32 addr, u32 rgba8, u32 dirXYZ)
{
  store(rgba8, addr, 0);

  if(dirXYZ) {
    store(dirXYZ, addr, 8);
    store(dirXYZ, addr, 12);
  }

  store(rgba8, addr, 4);
}

/**
 * Sets the number of active directional lights.
 * @param count range: 0 - LIGHT_COUNT
 */
command<9> T3DCmd_LightCount(u8 count)
{
  store(count, ACTIVE_LIGHT_SIZE);
}

/**
 * Sets various render-mode settings.
 * @param culling for RDPQ_Triangle, 0=front, 1=back, >1=none
 * @param triCommand for RDPQ_Triangle
 */
command<6> T3DCmd_RenderMode(u8 culling, u32 triCommand) {
  store(culling, FACE_CULLING);

  // Mipmap setting (pulled out from RDPQ_Triangle)
  u8 mipmap = load(RDPQ_OTHER_MODES);
  mipmap &= 0x38;
  triCommand |= mipmap;

  store(triCommand, TRI_COMMAND);
}

function mulMat4Mat4_func(u32<$s2> addrOut, u32<$s3> addrMatL, u32<$s4> addrMatR) {
  mulMat4Mat4(addrOut, addrMatL, addrMatR);
}

/**
 * Normalize a matrix vector (column) in memory and saves it as a fraction.
 * This is used to normalize the normal matrix.
 *
 * @param addrIn vector input address (s16.16 format)
 * @param addrOut vector output address (s0.16 format)
 */
function normalizeMatrixVector(u32<$s4> addrIn, u32<$t1> addrOut)
{
  vec32 v = load(addrIn, 0x00).xyzw;

  // get vector length
  vec32 vLenInv = v * v;
  vec32 tmp = vLenInv + vLenInv.yyyyYYYY;
  vLenInv   = vLenInv + tmp.zzzzZZZZ;

  // inverse of the length
  vLenInv.w = invert_half_sqrt(vLenInv).x;
  vLenInv >>= 9;

  v *= vLenInv.wwwwWWWW; // normalize
  v:sfract += v:sfract; // prevent over/underflow

  store(v:sfract.xyzw, addrOut, 0x00);

  addrIn += 0x10;
  addrOut += 0x8;
}

/**
 * Manages the matrix stack, implements 'push'/'pop' as well as 'set'.
 * The actual stack itself is held in RDRAM, only the current matrix is in DMEM.
 *
 * @param stackAdvance byte 0  : (internal)
 *                     byte 1-2: bytes to advance the stack pointer as an s16
 *                     byte 3  : flags (1=mul, 2=only advance)
 * @param addressMat RDRAM address to load matrix from
 */
command<2> T3DCmd_MatrixStack(s32 stackAdvance, u32 addressMat)
{
  #define MATRIX_TEMP_MV  CLIP_BUFFER_TMP
  #define MATRIX_TEMP_MUL CLIP_BUFFER_RESULT
  u32<$s4> dmaDest;

  u16 doMultiply = stackAdvance & 0b01;
  u16 onlyStackMove = stackAdvance & 0b10;

  stackAdvance:s16 = load_arg(1); // re-load from args to get sign extension

  s32 stackPtr = load(MATRIX_STACK_PTR);
  stackPtr += stackAdvance;
  store(stackPtr, MATRIX_STACK_PTR);

  // only move the stack pointer, can be used to prepare following matrix_set calls
  if(onlyStackMove)exit;
  dmaDest = MATRIX_TEMP_MV; // load new matrix
  resolveSegmentAddr(addressMat, addressMat);

  // stackAdvance less than zero -> matrix pop, load matrix from stack
  if(stackAdvance < 0)addressMat = stackPtr;
  u32<$s0> addrRDRAM = addressMat & 0xFFFFFF;

  dma_in(dmaDest, addrRDRAM, MATRIX_SIZE);
  u32<$t1> normOut = MATRIX_NORMAL;

  // if we advanced the stack, we need to multiply by the previous matrix
  if(doMultiply) {
    // load the mat. to multiply with from the stack...
    dmaDest = MATRIX_TEMP_MUL;
    addrRDRAM = stackPtr -  MATRIX_SIZE;
    dma_in(dmaDest, addrRDRAM, MATRIX_SIZE);

    // ...then multiply and store back top the same pos. in DMEM
    u32<$s2> mulDest = MATRIX_TEMP_MV;
    u32<$s3> mulLeft = MATRIX_TEMP_MUL;
    dmaDest = MATRIX_TEMP_MV;
    mulMat4Mat4_func(mulDest, mulLeft, dmaDest);
  }

  // save calc. matrix back to the stack
  addrRDRAM = stackPtr;
  dma_out(dmaDest, addrRDRAM, MATRIX_SIZE); // async

  // now grab the normal matrix and store it in a special slot.

  u32<$s2> mulDest = MATRIX_MVP;
  normalizeMatrixVector(dmaDest, normOut);
  u32<$s3> mulLeft = MATRIX_PROJ;
  normalizeMatrixVector(dmaDest, normOut);
  normalizeMatrixVector(dmaDest, normOut);
  undef dmaDest;

  // ...followed by applying the projection matrix, storing it in a special slot too.
  // Together, these two special slots are used for vertex transformation later on.
  u32<$s4> mulRight = MATRIX_TEMP_MV;
  mulMat4Mat4_func(mulDest, mulLeft, mulRight);

  #undef MATRIX_TEMP_MV
  #undef MATRIX_TEMP_MUL
}

/**
 * Sets a new projection matrix.
 * @param addressMat RDRAM address to load matrix from
 */
command<8> T3DCmd_MatProjectionSet(u32 addressMat) {
  u32<$s0> addrRDRAM = addressMat & 0xFFFFFF;
  dma_in(MATRIX_PROJ, addrRDRAM, 0x40);
}

/**
 * Stores a 32-bit word at an arbitrary address in DMEM.
 * This can be used to set segment addresses.
 * @param DMEM address in LSB 16 bits
 * @param value value to store
 */
command<3> T3DCmd_SetWord(u16 addrDMEM, u32 value) {
  store(value, addrDMEM);
}

/**
 * Sets the UV generation function.
 * @param uvFunc function address in IMEM
 * @param params user-defined parameters (2x u16 value)
 */
command<7> T3DCmd_SetUVGen(u16 uvFunc, u32 params) {
  store(uvFunc, VERTEX_FX_FUNC);
  store(params, UV_GEN_PARAMS);
}


/**
 * Draws a triangle to the screen, if necessary also performs clipping.
 *
 * @param vert0 16-LSB contain DMEM address for the first vertex
 * @param vert1 LSB/MSB contain DMEM address for the second + third vertex
 */
command<0> T3DCmd_TriDraw(u32 vert0, u32 vert1)
{
  //asm("emux_trace_start"); //asm("emux_trace_stop");

  // Note: vert1 & vert2 are switched, this avoids an additional instruction here.
  // We can't switch them on the CPU, as RDPQ_Triangle loads them from DMEM, so the order is different
  u32<$a2> vert2 = vert1 >> 16;

  {
    u32<$v1> vertAddr = get_cmd_address(2); // where to load the vertex pointers from
    u32<$sp> rejectDest = RSPQ_Loop; // jump-target for rejected/culled tris

    RDPQ_Triangle_Send_Async(vert0, vert1, vert2, rejectDest);
    u16 currOffset = load(RDPQ_TRI_BUFF_OFFSET);

    if(vertAddr == 0)
    {
      // if a triangle was generated, change the offset to swap output-buffers
      // the DMA is still active at this point, so we can only re-use it after a next send or sync
      currOffset ^= RDP_CMD_MAX_SIZE; // note: overflows into the next buffer
      store(currOffset, RDPQ_TRI_BUFF_OFFSET);
      exit;
    }

    // reload vertex indices, 'RDPQ_Triangle_Send_Async' may have modified them
    vert2:u16 = load_arg(0x06);
    vert1:u16 = load_arg(0x04);

    // we need to clip now, first wait for any triangle still in flight
    // this is necessary as clipping uses both buffers used as outputs
    RDPQ_Triangle_Send_End(); // <- resets 'RDPQ_TRI_BUFF_OFFSET' to zero

    vert0:u16 = load_arg(0x02); // a0 gets overwritten by 'RDPQ_Triangle_Send_End'
  }

  // Now we need to perform clipping, the code for this is in a separate overlay.
  // Check if already loaded, or load it in here otherwise.
  // It will stay until the next tri-sync command (or if a different overlay is executed)
  u8 clipLoaded = load(CLIP_CODE_ADDR);
  if(!clipLoaded)
  {
    u32<$s4> targetImem = CLIPPING_CODE_TARGET;
    u32<$s0> codeAddr = load(CLIP_CODE_ADDR);
    u16<$t0> codeSize = load(CLIP_CODE_SIZE);

    // mark as loaded, 'codeSize' is guaranteed to be non-zero in the LSB
    store(codeSize:u8, CLIP_CODE_ADDR);

    //printf("clip: %x, s:%x -> %x\n", codeAddr, codeSize, targetImem);
    dma_in(targetImem, codeAddr, codeSize);
  }

  DO_CLIPPING:
    RA:u16 = RSPQ_Loop;
    store(RA:u16, CLIP_RA);
    goto CLIPPING_CODE_TARGET;
}

/**
 * Syncs triangle calls, wrapper for 'RDPQ_Triangle_Send_Async'.
 */
command<12> T3DCmd_TriSync()
{
  u8 clipLoaded = load(CLIP_CODE_ADDR);
  u32<$s4> targetImem = CLIPPING_CODE_TARGET; // (delay-slot filler)

  // no clipping happened, just sync the triangle
  if(!clipLoaded)goto RDPQ_Triangle_Send_End;

  u32<$s0> codeAddr = load(CLIP_CODE_ORG_ADDR);
  u16<$t0> codeSize = load(CLIP_CODE_SIZE);

  //printf("main: %x, s:%x -> %x\n", codeAddr, codeSize, targetImem);
  dma_in_async(targetImem, codeAddr, codeSize); // RDPQ_Triangle_Send_End waits for DMA

  RA = RSPQ_Loop;
  store(ZERO:u8, CLIP_CODE_ADDR); // mark as not loaded
  goto RDPQ_Triangle_Send_End;
}

function DMAOutAsync();

/**
 * Loads and permanently replaces a part of t3d's ucode.
 * This will DMA new code into a given address and DMA's it back
 * to RDRAM to persist it across overlay switches.
 * This is used to implement different vertex pipelines in t3d.
 *
 * @param rdramLoad address to load the new ucode from
 * @param rdramStore address to save back (must point into the main t3d overlay)
 * @param imemAddrSize high-s16: IMEM address, low-s16: size in bytes
 */
command<13> T3DCmd_LoadUcode(u32 rdramLoad, u32 rdramStore, u32 imemAddrSize)
{
  u16<$s4> dmaImem = imemAddrSize >> 16;
  u32<$t0> dmaSize = imemAddrSize & 0xFFFF;
  u32<$s0> addrRDRAM = rdramLoad;

  dma_in(dmaImem, addrRDRAM, dmaSize);

  addrRDRAM = rdramStore;
  RA = RSPQ_Loop; // @TODO: add RSPL opt for this (needs auto. RA set)
  goto DMAOutAsync;
}

#endif



